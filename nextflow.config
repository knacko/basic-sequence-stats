manifest {
  author = 'Andrew Lindsay'
  description = 'Raw Read QC'
  mainScript = 'main.nf'
  nextflowVersion = '>=20.01.0'
  version = '0.0.1'
}

params {
  profile = false
  cache = ''
  
  // Input options
  folder = null
  sheet = null
  platform = null
  outdir = null

  // Folder search options
  pairedIlluminaSuffixes = ['*_R{1,2}_001', '*_R{1,2}', '*_{1,2}' ]
  singleIlluminaSuffixes = ['*_R{1,2}_001', '*_R{1,2}', '*_{1,2}' ]
  nanoporeSuffixes = ['*_barcode[0-9][0-9]*','*_barcode[0-9][0-9][0-9]*']
  fastqExts = ['.fastq.gz', '.fq.gz', '.fastq', '.fq']
  pairedIlluminaSearchPath = makeFastqSearchPath( params.pairedIlluminaSuffixes, params.fastqExts )
  singleIlluminaSearchPath = makeFastqSearchPath( params.singleIlluminaSuffixes, params.fastqExts )
  nanoporeSearchPath = makeFastqSearchPath( params.nanoporeSuffixes, params.fastqExts )  
}

profiles {
  conda {
    process.conda = "$baseDir/environments/environment.yml"
    if (params.cache){
     conda.cacheDir = params.cache
    }
  }
}

def makeFastqSearchPath (fastqSuffixes, fastqExts) {
    if (params.folder) {
      def fastqSearchPath = []
      for (suffix in fastqSuffixes){
          for (ext in fastqExts){
              fastqSearchPath.add(params.folder.toString() + '**/' + suffix.toString() + ext.toString())
          }
      }
      return fastqSearchPath
    }
}


// Load modules.config for DSL2 module specific options
includeConfig 'conf/modules.config'

// Function to ensure that resource requirements don't go beyond
// a maximum limit
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
            return obj
        }
    }
}